#!/usr/bin/env python

import argparse
import os, glob
import numpy as np
import yaml

# Use case : python npy_to_rttm.py --exp ${VALIDATE_DIR} \
#                                  --scores ${OUTPUT_DIR}/BabyTrain \
#                                  --mode speech

parser = argparse.ArgumentParser(description="Given :\n"
                                             "1) a directory such as the one generated by the validation step\n"
                                             "2) the directory where the raw scores of the application step have been stored (.npy files)\n"
                                             "3) a predicting mode (speech, or talker role)"
                                             "4) the frame step used for generating the features" 
                                             "Generates .rttm files whose labels have been determined based on the tresholds computed" 
                                             "in the development phase.")

parser.add_argument("--val",
                    help="""The experiment directory where the model """
                         """has been validated""",
                    type=str, required=True)
parser.add_argument("--protocol",
                    help="The name of the protocol on which the test was run")
parser.add_argument("--scores",
                    help="""The directory where the scores"""
                    """ are stored (.npy files).""",
                    type=str, required=True)
parser.add_argument("--step", help="Size of a frame (in s, default to 0.01 ms)",
                    type=float, default=0.01) # that one could be read in config.yml though
args = parser.parse_args()

validation_dir = args.val
if not os.path.isdir(os.path.join(validation_dir)):
    raise ValueError("""The model hasn't been validated yet."""
                     """The directory %s can't be found.""" % validation_dir)

# Get name of label on which validation was run
##Â Take abspath first, because if validation_dir ends with trailing "/"
## the basename will be ""...
folder_name = os.path.basename(os.path.abspath(validation_dir))
if "KCHI" in folder_name:
    print("Extracting key-child speech.")
    mode = "KCHI"
elif "CHI" in folder_name:
    print("Extracting child speech.")
    mode = "CHI"
elif "MAL" in folder_name:
    print("Extracting male speech.")
    mode = "MAL"
elif "FEM" in folder_name:
    print("Extracting female speech.")
    mode = "FEM"
elif "SPEECH" in folder_name:
    print("Extracting speech.")
    mode = "SPEECH"
else:
    raise ValueError("Can't decide what label needs to be predicted : "
                     "%s should contain one of the following "
                     "[KCHI,CHI,FEM,MAL,SPEECH]" % folder_name)

# Let's look for the config file to see if it is
# the number of classes
config_file = glob.glob('%s/**/config.yml' % '/'.join(validation_dir.split("/")[0:2]), recursive=True)

labels = np.asarray(["CHI", "FEM", "KCHI", "MAL"])
if len(config_file) != 1:
    raise ValueError("Something went wrong while looking for the config.yml file :\nFiles found : %s" % config_file)
else:
    config_file = config_file[0]
    config = yaml.load(open(config_file))
    if "speech" in config["task"]["params"] and config["task"]["params"]["speech"]:
        labels = np.append(labels, "SPEECH")
    if "overlap" in config["task"]["params"] and config["task"]["params"]["overlap"]:
        labels = np.append(labels, "OVERLAP")

PROTOCOL_TRAIN = validation_dir.split('/')[-2]
if "AMI" in PROTOCOL_TRAIN or "CHiME5" in PROTOCOL_TRAIN:
    labels = np.delete(labels, np.where(labels == ["KCHI", "CHI"]))
labels = list(labels)
# Read treshold
params = yaml.load(open(os.path.join(validation_dir,
                        "{}.development".format(args.protocol),
                        "params.yml")),
                   Loader=yaml.FullLoader)
treshold = params["params"]["offset"]

# Read scores
npy_files = glob.glob(os.path.join(args.scores, "*.npy"))

if len(list(npy_files)) == 0:
    print("No .npy files have been found.")

output_dir = os.path.join(args.scores, mode)
try:
    # Create target Directory
    os.mkdir(output_dir)
    print("Directory ", output_dir, " created ")
except FileExistsError:
    print("Directory ", output_dir, " already exists")

for npy in npy_files:
    print("Treating %s " % os.path.basename(npy))
    output_file = os.path.join(output_dir, os.path.basename(npy).replace(".npy", ".rttm"))
    basename = os.path.basename(output_file).replace(".rttm", "")
    role_scores = np.load(npy)

    if mode == "SPEECH" and "SPEECH" not in labels:
        speech_scores = np.sum(role_scores, axis=1)
    else:
        idx = labels.index(mode)
        speech_scores = role_scores[:, idx]

    is_speech = speech_scores > treshold
    is_speech = np.hstack([False, is_speech, False]) # Useful for boundaries
    # Starts are the ones whose previous element is False, and curr element is
    # True. Same principles for ends
    starts = (~is_speech[:-1] & is_speech[1:]).nonzero()
    ends = (is_speech[:-1] & ~is_speech[1:]).nonzero()

    with open(output_file, 'w') as f:
        for start, end in zip(starts[0], ends[0]):
            start_s = start * args.step
            duration_s = (end - start) * args.step
            f.write("""SPEAKER %s\t1\t%.3f\t%.3f"""
                    """\t<NA>\t<NA>\t%s\t<NA>\t<NA>\n""" % (basename,
                                                            start_s, duration_s,
                                                            mode))

